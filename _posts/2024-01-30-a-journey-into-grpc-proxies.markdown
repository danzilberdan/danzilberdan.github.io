---
layout: single
title: A Journey into gRPC Proxies
categories: jekyll update TIL
---

[Temporal](https://temporal.io/) is a framework designed for executing long-running tasks in a reliable and scalable manner. It leverages the event sourcing pattern to ensure durability by capturing and storing the history of events associated with each task. This approach enables the playback of event histories, allowing for the reconstruction of the application's state at any point in time. Through its use of event sourcing, this framework provides a robust solution for managing complex, time-sensitive processes while ensuring fault tolerance and resilience.

Have you ever envisioned a serverless solution that enables long running, durable excution that not only eliminates the need for maintaining servers but also offers a cost-effective pay-as-you-go model? Well, I embarked on such a journey, crafting a Temporal solution that abstracts away the complexities of worker processes and brings the power of Temporal to a serverless paradigm.

Before we dive in, if this sounds interesting to you, get started [here](https://github.com/danzilberdan/Durable-Serverless-Starter).

## Discovering Temporal's Potential
My journey begins with a deep dive into Temporal, captivated by its behavior and functionality. However, the hurdle of constantly maintaining worker processes connected to the Temporal cluster led me to conceive a serverless solution. This solution promised not only freedom from server management but also a cost-efficient model where payment only corresponds to the actual execution time.

## Crafting the Temporal Proxy
One of the pivotal components in realizing this serverless dream was the creation of a Temporal proxy – a gRPC proxy implemented in Python. This proxy serves as the bridge between user requests and the Temporal cluster, ensuring authentication and security.

## User-Specific Temporal Interaction
To safeguard user data and prevent unauthorized access, each user is assigned their dedicated namespace within Temporal. The Temporal proxy, acting as a guardian, authenticates requests, rejecting any attempts to access namespaces not associated with the user.

## The Challenge of gRPC
Creating a transparent proxy for HTTP requests with JSON data is straightforward. However, gRPC presented a unique challenge due to the binary nature of protobuf data. Parsing, serializing, and deserializing this data, all while dynamically handling variations in the namespace parameter's position, requires a sophisticated approach.

## Python's Magic for gRPC Proxies
Enter Python's magic features – the perfect toolkit for tackling the complexities of gRPC proxies. In my approach to using gRPC, I departed from the conventional strong typing and embraced the flexibility of Python's dynamic features. I implemented a gRPC server capable of generically capturing and handling various method invocations.

### Background
The provided Python code serves as a proxy for handling gRPC requests related to Temporal's workflow and operator services. The focus of our discussion will be on the __getattr__ method within the ProxyServicer class.

### Understanding getattr
In Python, `__getattr__` is a special method that gets called when an attribute lookup fails. It allows objects to dynamically handle attribute access, making it a powerful tool for customization.

Dynamic Method Handling:
```python
class ProxyServicer:
    def __getattr__(self, __name: str) -> Any:
        async def dynamic(request, context):
            try:
                await self.validate_request(__name, request, context)
                stub_func = self.get_stub_method(__name)
                response = stub_func(request, timeout=timeout)
                return response
            except RpcError as e:
                await context.abort(e.code(), e.details())
            except Exception as e:
                await context.abort(StatusCode.UNKNOWN, str(e))
        return dynamic
```
### Breaking Down the Implementation:
#### Method Generation:
The __getattr__ method is designed to dynamically generate methods for handling gRPC requests.
It creates an asynchronous function named dynamic for each method that is requested dynamically.

#### Request Validation:
Before processing the request, the validate_request method is called to ensure the request is valid and authorized. Here we don't really know what is the internal structure of the protobuf request. All we care about is that the provided namespace matches the API key of the user.

#### Response Handling:
The method fetches the corresponding gRPC stub function using `self.get_stub_method(__name)` - Also uses `__getattr__` but on the stub generated by gRPC!
It then asynchronously fetches the response.

#### Dynamic Method Handling:
This implementation allows the ProxyServicer to dynamically handle any gRPC method, making it adaptable to changes in the system.

### Integration with Temporal's Schema
This is great, but ultimately, we need to capture the data, serialize it, and then deserialize it. Let's delve into the process and understand how it's done.

```python
async def run():
    channel = grpc.insecure_channel(TEMPORAL_HOST)
    wf_stub = WorkflowServiceStub(channel)
    op_stub = OperatorServiceStub(channel)
    
    wf_servicer = ProxyServicer(wf_stub)
    op_servicer = ProxyServicer(op_stub)
    server = grpc.aio.server()
    add_WorkflowServiceServicer_to_server(wf_servicer, server)
    add_OperatorServiceServicer_to_server(op_servicer, server)
    
    server.add_insecure_port('[::]:7234')
    await server.start()
    await server.wait_for_termination()
```
This Python code sets up an asynchronous gRPC server for Temporal workflow and operator services. It establishes a connection to a Temporal server, creates service stubs, initializes the ProxyServicer we have seen before, configures the server, and starts it. The server proxies Temporal workflow and operator requests through gRPC communication. `add_WorkflowServiceServicer_to_server` and `add_OperatorServiceServicer_to_server` are the functions that actually add provide the server with the serialization and deserialization logic allowing us to ignore the internal structure of the protobuf messages and handle them dynamically in Python.

## Seamless Client Interaction
By implementing magic functions, the ProxyServicer class facilitated seamless interaction between clients and the remote server. Requests are intelligently processed, securely forwarded to the gRPC server, and responses seamlessly returned to clients, creating a transparent gRPC proxy.

# Conclusion
In creating a serverless temporal solution, combining Temporal's strength with Python's capabilities showed us a way to make things simpler and more efficient. The gRPC proxy, using dynamic verification and metaprogramming, is proof of how we can create smart solutions for tough problems. As serverless technology keeps getting better, our journey is a guide for anyone dealing with temporal workflows and serverless architecture.